-- -------------------------------------------------------------
-- 
-- File Name: /home/sky/Documents/MATLAB/Turbo_codes/codegen/tbcdec/hdlsrc/tbcdec_fixpt_tb.vhd
-- Created: 2019-04-09 14:53:19
-- 
-- Generated by MATLAB 9.5, MATLAB Coder 4.1 and HDL Coder 3.13
-- 
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 1
-- Target subsystem base rate: 1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: tbcdec_fixpt_tb
-- Source Path: 
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_textio.ALL;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
LIBRARY STD;
USE STD.textio.ALL;
LIBRARY work;
USE work.tbcdec_fixpt_pkg.ALL;
USE work.tbcdec_fixpt_tb_pkg.ALL;

ENTITY tbcdec_fixpt_tb IS
END tbcdec_fixpt_tb;


ARCHITECTURE rtl OF tbcdec_fixpt_tb IS

  -- Component Declarations
  COMPONENT tbcdec_fixpt
    PORT( r1_1                            :   IN    vector_of_std_logic_vector16(0 TO 7);  -- sfix16_En11 [8]
          r2_1                            :   IN    vector_of_std_logic_vector16(0 TO 7);  -- sfix16_En12 [8]
          r3                              :   IN    vector_of_std_logic_vector16(0 TO 7);  -- sfix16_En12 [8]
          iter                            :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
          intlv                           :   IN    vector_of_std_logic_vector8(0 TO 7);  -- uint8 [8]
          Lc                              :   IN    std_logic_vector(15 DOWNTO 0);  -- ufix16_En11
          dec_out                         :   OUT   vector_of_std_logic_vector8(0 TO 7);  -- int8 [8]
          LLR                             :   OUT   vector_of_std_logic_vector16(0 TO 7)  -- sfix16_En6 [8]
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : tbcdec_fixpt
    USE ENTITY work.tbcdec_fixpt(rtl);

  -- Signals
  SIGNAL clk                              : std_logic;
  SIGNAL reset                            : std_logic;
  SIGNAL enb                              : std_logic;
  SIGNAL dec_out_addr                     : std_logic;  -- ufix1
  SIGNAL dec_out_lastAddr                 : std_logic;  -- ufix1
  SIGNAL LLR_addr                         : std_logic;  -- ufix1
  SIGNAL LLR_lastAddr                     : std_logic;  -- ufix1
  SIGNAL LLR_done                         : std_logic;  -- ufix1
  SIGNAL rdEnb                            : std_logic;
  SIGNAL LLR_done_enb                     : std_logic;  -- ufix1
  SIGNAL resetn                           : std_logic;
  SIGNAL check2_done                      : std_logic;  -- ufix1
  SIGNAL snkDone                          : std_logic;
  SIGNAL snkDonen                         : std_logic;
  SIGNAL tb_enb                           : std_logic;
  SIGNAL dec_out_done                     : std_logic;  -- ufix1
  SIGNAL dec_out_done_enb                 : std_logic;  -- ufix1
  SIGNAL check1_done                      : std_logic;  -- ufix1
  SIGNAL ce_out                           : std_logic;
  SIGNAL rawData_r1_1                     : vector_of_signed16(0 TO 7);  -- sfix16_En11 [8]
  SIGNAL holdData_r1_1                    : vector_of_signed16(0 TO 7);  -- sfix16_En11 [8]
  SIGNAL rawData_r2_1                     : vector_of_signed16(0 TO 7);  -- sfix16_En12 [8]
  SIGNAL holdData_r2_1                    : vector_of_signed16(0 TO 7);  -- sfix16_En12 [8]
  SIGNAL rawData_r3                       : vector_of_signed16(0 TO 7);  -- sfix16_En12 [8]
  SIGNAL holdData_r3                      : vector_of_signed16(0 TO 7);  -- sfix16_En12 [8]
  SIGNAL rawData_iter                     : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL holdData_iter                    : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL rawData_intlv                    : vector_of_unsigned8(0 TO 7);  -- uint8 [8]
  SIGNAL holdData_intlv                   : vector_of_unsigned8(0 TO 7);  -- uint8 [8]
  SIGNAL rawData_Lc                       : unsigned(15 DOWNTO 0);  -- ufix16_En11
  SIGNAL holdData_Lc                      : unsigned(15 DOWNTO 0);  -- ufix16_En11
  SIGNAL r1_1_offset                      : vector_of_signed16(0 TO 7);  -- sfix16_En11 [8]
  SIGNAL r1_1_1                           : vector_of_signed16(0 TO 7);  -- sfix16_En11 [8]
  SIGNAL r1_1_2                           : vector_of_std_logic_vector16(0 TO 7);  -- ufix16 [8]
  SIGNAL r2_1_offset                      : vector_of_signed16(0 TO 7);  -- sfix16_En12 [8]
  SIGNAL r2_1_1                           : vector_of_signed16(0 TO 7);  -- sfix16_En12 [8]
  SIGNAL r2_1_2                           : vector_of_std_logic_vector16(0 TO 7);  -- ufix16 [8]
  SIGNAL r3_offset                        : vector_of_signed16(0 TO 7);  -- sfix16_En12 [8]
  SIGNAL r3_1                             : vector_of_signed16(0 TO 7);  -- sfix16_En12 [8]
  SIGNAL r3_2                             : vector_of_std_logic_vector16(0 TO 7);  -- ufix16 [8]
  SIGNAL iter_offset                      : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL iter_1                           : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL iter_2                           : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL intlv_offset                     : vector_of_unsigned8(0 TO 7);  -- uint8 [8]
  SIGNAL intlv_1                          : vector_of_unsigned8(0 TO 7);  -- uint8 [8]
  SIGNAL intlv_2                          : vector_of_std_logic_vector8(0 TO 7);  -- ufix8 [8]
  SIGNAL Lc_offset                        : unsigned(15 DOWNTO 0);  -- ufix16_En11
  SIGNAL Lc_1                             : unsigned(15 DOWNTO 0);  -- ufix16_En11
  SIGNAL Lc_2                             : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL dec_out                          : vector_of_std_logic_vector8(0 TO 7);  -- ufix8 [8]
  SIGNAL LLR                              : vector_of_std_logic_vector16(0 TO 7);  -- ufix16 [8]
  SIGNAL dec_out_signed                   : vector_of_signed8(0 TO 7);  -- int8 [8]
  SIGNAL dec_out_expected_1               : vector_of_signed8(0 TO 7);  -- int8 [8]
  SIGNAL dec_out_ref                      : vector_of_signed8(0 TO 7);  -- int8 [8]
  SIGNAL dec_out_testFailure              : std_logic;  -- ufix1
  SIGNAL LLR_signed                       : vector_of_signed16(0 TO 7);  -- sfix16_En6 [8]
  SIGNAL LLR_expected_1                   : vector_of_signed16(0 TO 7);  -- sfix16_En6 [8]
  SIGNAL LLR_ref                          : vector_of_signed16(0 TO 7);  -- sfix16_En6 [8]
  SIGNAL LLR_testFailure                  : std_logic;  -- ufix1
  SIGNAL testFailure                      : std_logic;  -- ufix1

BEGIN
  u_tbcdec_fixpt : tbcdec_fixpt
    PORT MAP( r1_1 => r1_1_2,  -- sfix16_En11 [8]
              r2_1 => r2_1_2,  -- sfix16_En12 [8]
              r3 => r3_2,  -- sfix16_En12 [8]
              iter => iter_2,  -- uint8
              intlv => intlv_2,  -- uint8 [8]
              Lc => Lc_2,  -- ufix16_En11
              dec_out => dec_out,  -- int8 [8]
              LLR => LLR  -- sfix16_En6 [8]
              );

  dec_out_lastAddr <= '1';

  LLR_lastAddr <= '1';

  LLR_done_enb <= LLR_done AND rdEnb;

  LLR_done <= LLR_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_2_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check2_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF LLR_done_enb = '1' THEN
        check2_done <= LLR_done;
      END IF;
    END IF;
  END PROCESS checkDone_2_process;

  snkDonen <=  NOT snkDone;

  tb_enb <= resetn AND snkDonen;

  
  rdEnb <= tb_enb WHEN snkDone = '0' ELSE
      '0';

  dec_out_done_enb <= dec_out_done AND rdEnb;

  clk_gen: PROCESS 
  BEGIN
    clk <= '1';
    WAIT FOR 5 ns;
    clk <= '0';
    WAIT FOR 5 ns;
    IF snkDone = '1' THEN
      clk <= '1';
      WAIT FOR 5 ns;
      clk <= '0';
      WAIT FOR 5 ns;
      WAIT;
    END IF;
  END PROCESS clk_gen;

  reset_gen: PROCESS 
  BEGIN
    reset <= '1';
    WAIT FOR 20 ns;
    WAIT UNTIL clk'event AND clk = '1';
    WAIT FOR 2 ns;
    reset <= '0';
    WAIT;
  END PROCESS reset_gen;

  resetn <=  NOT reset;

  dec_out_done <= dec_out_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_1_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      check1_done <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF dec_out_done_enb = '1' THEN
        check1_done <= dec_out_done;
      END IF;
    END IF;
  END PROCESS checkDone_1_process;

  snkDone <= check1_done AND check2_done;

  enb <= rdEnb AFTER 2 ns;

  ce_out <= enb AND (rdEnb AND tb_enb);

  -- Data source for r1_1
  rawData_r1_1(0) <= to_signed(-16#0891#, 16);
  rawData_r1_1(1) <= to_signed(16#06AB#, 16);
  rawData_r1_1(2) <= to_signed(-16#063E#, 16);
  rawData_r1_1(3) <= to_signed(16#09B9#, 16);
  rawData_r1_1(4) <= to_signed(-16#0CC4#, 16);
  rawData_r1_1(5) <= to_signed(-16#082B#, 16);
  rawData_r1_1(6) <= to_signed(16#0717#, 16);
  rawData_r1_1(7) <= to_signed(16#0B75#, 16);

  -- holdData reg for r1_1
  stimuli_r1_1_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_r1_1 <= (OTHERS => (OTHERS => 'X'));
    ELSIF clk'event AND clk = '1' THEN
      holdData_r1_1 <= rawData_r1_1;
    END IF;
  END PROCESS stimuli_r1_1_process;

  -- Data source for r2_1
  rawData_r2_1(0) <= to_signed(-16#03F4#, 16);
  rawData_r2_1(1) <= to_signed(-16#03C7#, 16);
  rawData_r2_1(2) <= to_signed(16#067B#, 16);
  rawData_r2_1(3) <= to_signed(-16#0F26#, 16);
  rawData_r2_1(4) <= to_signed(-16#1D62#, 16);
  rawData_r2_1(5) <= to_signed(-16#1C46#, 16);
  rawData_r2_1(6) <= to_signed(-16#1014#, 16);
  rawData_r2_1(7) <= to_signed(16#00E3#, 16);

  -- holdData reg for r2_1
  stimuli_r2_1_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_r2_1 <= (OTHERS => (OTHERS => 'X'));
    ELSIF clk'event AND clk = '1' THEN
      holdData_r2_1 <= rawData_r2_1;
    END IF;
  END PROCESS stimuli_r2_1_process;

  -- Data source for r3
  rawData_r3(0) <= to_signed(16#0784#, 16);
  rawData_r3(1) <= to_signed(-16#0BE9#, 16);
  rawData_r3(2) <= to_signed(16#0D83#, 16);
  rawData_r3(3) <= to_signed(-16#03B0#, 16);
  rawData_r3(4) <= to_signed(16#03FF#, 16);
  rawData_r3(5) <= to_signed(16#105B#, 16);
  rawData_r3(6) <= to_signed(16#1616#, 16);
  rawData_r3(7) <= to_signed(-16#03E0#, 16);

  -- holdData reg for r3
  stimuli_r3_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_r3 <= (OTHERS => (OTHERS => 'X'));
    ELSIF clk'event AND clk = '1' THEN
      holdData_r3 <= rawData_r3;
    END IF;
  END PROCESS stimuli_r3_process;

  -- Data source for iter
  rawData_iter <= to_unsigned(16#05#, 8);

  -- holdData reg for iter
  stimuli_iter_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_iter <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_iter <= rawData_iter;
    END IF;
  END PROCESS stimuli_iter_process;

  -- Data source for intlv
  rawData_intlv(0) <= to_unsigned(16#08#, 8);
  rawData_intlv(1) <= to_unsigned(16#02#, 8);
  rawData_intlv(2) <= to_unsigned(16#03#, 8);
  rawData_intlv(3) <= to_unsigned(16#01#, 8);
  rawData_intlv(4) <= to_unsigned(16#06#, 8);
  rawData_intlv(5) <= to_unsigned(16#05#, 8);
  rawData_intlv(6) <= to_unsigned(16#04#, 8);
  rawData_intlv(7) <= to_unsigned(16#07#, 8);

  -- holdData reg for intlv
  stimuli_intlv_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_intlv <= (OTHERS => (OTHERS => 'X'));
    ELSIF clk'event AND clk = '1' THEN
      holdData_intlv <= rawData_intlv;
    END IF;
  END PROCESS stimuli_intlv_process;

  -- Data source for Lc
  rawData_Lc <= to_unsigned(16#3298#, 16);

  -- holdData reg for Lc
  stimuli_Lc_process: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      holdData_Lc <= (OTHERS => 'X');
    ELSIF clk'event AND clk = '1' THEN
      holdData_Lc <= rawData_Lc;
    END IF;
  END PROCESS stimuli_Lc_process;

  stimuli_r1_1_1: PROCESS (rawData_r1_1, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      r1_1_offset <= holdData_r1_1;
    ELSE
      r1_1_offset <= rawData_r1_1;
    END IF;
  END PROCESS stimuli_r1_1_1;

  r1_1_1 <= r1_1_offset AFTER 2 ns;

  outputgen5: FOR k IN 0 TO 7 GENERATE
    r1_1_2(k) <= std_logic_vector(r1_1_1(k));
  END GENERATE;

  stimuli_r2_1_1: PROCESS (rawData_r2_1, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      r2_1_offset <= holdData_r2_1;
    ELSE
      r2_1_offset <= rawData_r2_1;
    END IF;
  END PROCESS stimuli_r2_1_1;

  r2_1_1 <= r2_1_offset AFTER 2 ns;

  outputgen4: FOR k IN 0 TO 7 GENERATE
    r2_1_2(k) <= std_logic_vector(r2_1_1(k));
  END GENERATE;

  stimuli_r3_1: PROCESS (rawData_r3, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      r3_offset <= holdData_r3;
    ELSE
      r3_offset <= rawData_r3;
    END IF;
  END PROCESS stimuli_r3_1;

  r3_1 <= r3_offset AFTER 2 ns;

  outputgen3: FOR k IN 0 TO 7 GENERATE
    r3_2(k) <= std_logic_vector(r3_1(k));
  END GENERATE;

  stimuli_iter_1: PROCESS (rawData_iter, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      iter_offset <= holdData_iter;
    ELSE
      iter_offset <= rawData_iter;
    END IF;
  END PROCESS stimuli_iter_1;

  iter_1 <= iter_offset AFTER 2 ns;

  iter_2 <= std_logic_vector(iter_1);

  stimuli_intlv_1: PROCESS (rawData_intlv, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      intlv_offset <= holdData_intlv;
    ELSE
      intlv_offset <= rawData_intlv;
    END IF;
  END PROCESS stimuli_intlv_1;

  intlv_1 <= intlv_offset AFTER 2 ns;

  outputgen2: FOR k IN 0 TO 7 GENERATE
    intlv_2(k) <= std_logic_vector(intlv_1(k));
  END GENERATE;

  stimuli_Lc_1: PROCESS (rawData_Lc, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      Lc_offset <= holdData_Lc;
    ELSE
      Lc_offset <= rawData_Lc;
    END IF;
  END PROCESS stimuli_Lc_1;

  Lc_1 <= Lc_offset AFTER 2 ns;

  Lc_2 <= std_logic_vector(Lc_1);

  outputgen1: FOR k IN 0 TO 7 GENERATE
    dec_out_signed(k) <= signed(dec_out(k));
  END GENERATE;

  -- Data source for dec_out_expected
  dec_out_expected_1(0) <= to_signed(16#01#, 8);
  dec_out_expected_1(1) <= to_signed(-16#01#, 8);
  dec_out_expected_1(2) <= to_signed(-16#01#, 8);
  dec_out_expected_1(3) <= to_signed(16#01#, 8);
  dec_out_expected_1(4) <= to_signed(16#01#, 8);
  dec_out_expected_1(5) <= to_signed(16#01#, 8);
  dec_out_expected_1(6) <= to_signed(-16#01#, 8);
  dec_out_expected_1(7) <= to_signed(16#01#, 8);

  dec_out_ref <= dec_out_expected_1;

  dec_out_signed_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      dec_out_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' AND dec_out_signed /= dec_out_ref THEN
        dec_out_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in dec_out_signed: Expected " & to_hex(dec_out_ref) & (" Actual " & to_hex(dec_out_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS dec_out_signed_checker;

  outputgen: FOR k IN 0 TO 7 GENERATE
    LLR_signed(k) <= signed(LLR(k));
  END GENERATE;

  -- Data source for LLR_expected
  LLR_expected_1(0) <= to_signed(16#00E0#, 16);
  LLR_expected_1(1) <= to_signed(-16#0100#, 16);
  LLR_expected_1(2) <= to_signed(-16#0280#, 16);
  LLR_expected_1(3) <= to_signed(16#0040#, 16);
  LLR_expected_1(4) <= to_signed(16#0040#, 16);
  LLR_expected_1(5) <= to_signed(16#0040#, 16);
  LLR_expected_1(6) <= to_signed(-16#0180#, 16);
  LLR_expected_1(7) <= to_signed(16#0100#, 16);

  LLR_ref <= LLR_expected_1;

  LLR_signed_checker: PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      LLR_testFailure <= '0';
    ELSIF clk'event AND clk = '1' THEN
      IF ce_out = '1' AND LLR_signed /= LLR_ref THEN
        LLR_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in LLR_signed: Expected " & to_hex(LLR_ref) & (" Actual " & to_hex(LLR_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS LLR_signed_checker;

  testFailure <= dec_out_testFailure OR LLR_testFailure;

  completed_msg: PROCESS (clk)
  BEGIN
    IF clk'event AND clk = '1' THEN
      IF snkDone = '1' THEN
        IF testFailure = '0' THEN
          ASSERT FALSE
            REPORT "**************TEST COMPLETED (PASSED)**************"
            SEVERITY NOTE;
        ELSE
          ASSERT FALSE
            REPORT "**************TEST COMPLETED (FAILED)**************"
            SEVERITY NOTE;
        END IF;
      END IF;
    END IF;
  END PROCESS completed_msg;

END rtl;

